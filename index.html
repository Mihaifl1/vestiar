<!doctype html>
<html lang="ro">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Vestiar – 6 uși • MQTT live (ping & LWT)</title>
<script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
<style>
  :root{
    --bg:#0b1220; --wall:#e5e7eb;
    --closed:#22c55e;  /* verde = LOCKED/îNCHIS (safe) */
    --open:#ef4444;    /* roșu  = UNLOCKED/DESCHIS */
    --nopower:#6b7280; /* gri   = fără alimentare / OFFLINE */
    --hinge:#94a3b8;
    --cardbg:#081021;
  }
  *{box-sizing:border-box}
  body{margin:0;background:linear-gradient(180deg,#051027, #071426);color:#fff;font-family:Inter,Segoe UI,Roboto,Arial}
  .wrap{max-width:1100px;margin:18px auto;padding:16px}
  h1{font-size:20px;margin:0 0 10px;color:#bfe3ff}
  .topbar{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-bottom:10px}
  .legend{font-size:13px;opacity:.95;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .legend span{display:inline-flex;gap:8px;align-items:center;padding:6px 8px;border-radius:8px;background:#081425;border:1px solid rgba(255,255,255,0.03)}
  .dot{width:10px;height:10px;border-radius:50%;display:inline-block}
  .c{background:var(--closed)} .o{background:var(--open)} .p{background:var(--nopower)}
  .conn{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:10px;background:#071428;border:1px solid #123;}
  .conn .dot{background:#ef4444} .conn.ok .dot{background:var(--closed)}
  button{padding:8px 12px;border-radius:8px;border:1px solid #234;background:linear-gradient(180deg,#0b2a3a,#052532);color:#fff;cursor:pointer}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06)}
  .plan{position:relative;width:100%;border-radius:12px;overflow:hidden;background:var(--cardbg);padding:12px;border:1px solid rgba(255,255,255,0.03)}
  .overlay{ position:relative; width:100%; height:420px; background: linear-gradient(90deg, rgba(255,255,255,0.02), transparent); }
  .door{
    position:absolute; left:0; top:0;
    --x: 0%; --y: 0%; --a: 0;
    transform: translate(var(--x), var(--y)) rotate(calc(var(--a) * 1deg));
    transform-origin: 0 0;
    width: 92px; height: 44px; cursor:pointer;
  }
  .door .hinge{ position:absolute; top:6px; width:8px; height:24px; background:var(--hinge); border-radius:4px; opacity:.95 }
  .door .leaf{ position:absolute; top:10px; width:76px; height:14px; border-radius:8px; background:var(--closed); border:1px solid rgba(0,0,0,0.6); transition: transform .28s ease, background .18s ease, box-shadow .18s ease }
  .door .label{ position:absolute; left:-10px; top:34px; font-size:12px; color:#cce7ff; text-shadow:0 1px 2px rgba(0,0,0,0.5); white-space:pre; text-align:center }
  .door[data-hinge="left"] .hinge{ left:-6px } .door[data-hinge="right"] .hinge{ right:-6px }
  .door[data-hinge="left"] .leaf{ left:0; transform-origin:left center } .door[data-hinge="right"] .leaf{ right:0; transform-origin:right center }
  .door[data-hinge="left"][data-swing="down"].open .leaf{ transform: rotate(60deg); background:var(--open); box-shadow:0 6px 12px rgba(0,0,0,.45) }
  .door[data-hinge="left"][data-swing="up"].open   .leaf{ transform: rotate(-60deg); background:var(--open); box-shadow:0 6px 12px rgba(0,0,0,.45) }
  .door[data-hinge="right"][data-swing="down"].open .leaf{ transform: rotate(-60deg); background:var(--open); box-shadow:0 6px 12px rgba(0,0,0,.45) }
  .door[data-hinge="right"][data-swing="up"].open   .leaf{ transform: rotate(60deg);  background:var(--open); box-shadow:0 6px 12px rgba(0,0,0,.45) }
  .door.nopower .leaf, .door.offline .leaf{ background:var(--nopower) }
  .door.offline{ cursor:not-allowed; opacity:0.9 }

  .controls{display:flex;gap:8px;margin-top:12px;align-items:center;flex-wrap:wrap}
  .info{margin-top:12px;font-size:13px;color:#c8dff0}
  .events{margin-top:12px;background:#031526;padding:10px;border-radius:8px;max-height:200px;overflow:auto;border:1px solid rgba(255,255,255,0.02)}
  .events div{padding:6px;border-bottom:1px dashed rgba(255,255,255,0.02);font-size:13px}
  .small{font-size:12px;color:#9fb8d6}
  .badge{display:inline-block;padding:4px 8px;border-radius:8px;background:#072434;color:#bfe3ff;border:1px solid rgba(255,255,255,0.03)}
</style>
</head>
<body>
<div class="wrap">
  <h1>Vestiar – control uși (MQTT) — Ping & LWT</h1>

  <div class="topbar">
    <div class="legend">
      <span><span class="dot c"></span> ÎNCHIS (LOCKED)</span>
      <span><span class="dot o"></span> DESCHIS (UNLOCKED)</span>
      <span><span class="dot p"></span> Fără alimentare / OFFLINE</span>
    </div>

    <div style="flex:1"></div>

    <div class="conn" id="conn"><span class="dot"></span><span id="connText">Se conectează la MQTT…</span></div>
    <button id="btnPingAll" class="ghost">Ping all</button>
    <div class="badge small" id="lastPing">—</div>
  </div>

  <div class="plan">
    <div class="overlay" id="overlay" style="height:420px">
      <!-- pozițiile ușilor (ajustează CONFIG în JS) -->
      <div class="door offline" id="d1" data-hinge="left"  data-swing="up"><div class="hinge"></div><div class="leaf"></div><div class="label">Ușa 1</div></div>
      <div class="door offline" id="d2" data-hinge="left"  data-swing="up"><div class="hinge"></div><div class="leaf"></div><div class="label">Ușa 2</div></div>
      <div class="door offline" id="d3" data-hinge="left"  data-swing="up"><div class="hinge"></div><div class="leaf"></div><div class="label">Ușa 3</div></div>
      <div class="door offline" id="d4" data-hinge="right" data-swing="up"><div class="hinge"></div><div class="leaf"></div><div class="label">Ușa 4</div></div>
      <div class="door offline" id="d5" data-hinge="right" data-swing="up"><div class="hinge"></div><div class="leaf"></div><div class="label">Ușa 5</div></div>
      <div class="door offline" id="d6" data-hinge="right" data-swing="up"><div class="hinge"></div><div class="leaf"></div><div class="label">Ușa 6</div></div>
    </div>

    <div class="controls">
      <div class="small">Status: <span id="statusText">init…</span></div>
      <div style="flex:1"></div>
      <div class="small">Offline timeout: <strong id="offlineMs">20s</strong></div>
    </div>

    <div class="info">
      <div class="small">Click pe o ușă pentru a trimite comanda LOCK/UNLOCK (dacă nu este offline).</div>
    </div>

    <div class="events" id="events"></div>
  </div>
</div>

<script>
/* =========================
   CONFIG: ajustați aici
   ========================= */
const CONFIG = {
  // poziții în pixeli relative la overlay (puteți modifica) - x,y în px, a = rotație în grade
  d1: { x: 60,  y: 40,  a: 0 },
  d2: { x: 220, y: 40,  a: 0 },
  d3: { x: 380, y: 40,  a: 0 },
  d4: { x: 540, y: 40,  a: 0 },
  d5: { x: 700, y: 40,  a: 0 },
  d6: { x: 860, y: 40,  a: 0 }
};
function applyConfig(){
  Object.keys(CONFIG).forEach(id=>{
    const el = document.getElementById(id);
    if(!el) return;
    const {x,y,a} = CONFIG[id];
    // punem in procente relative la overlay dimensiuni
    el.style.setProperty('--x', `${x}px`);
    el.style.setProperty('--y', `${y}px`);
    el.style.setProperty('--a', (Number(a)||0));
  });
}
applyConfig();

/* =========================
   MQTT setup
   ========================= */
const brokerUrl = "wss://broker.emqx.io:8084/mqtt"; // schimbă dacă ai alt broker
const options = {
  clientId: "web_" + Math.random().toString(16).slice(2),
  clean: true,
  reconnectPeriod: 2000,
};
const client = mqtt.connect(brokerUrl, options);

const connBadge = document.getElementById('conn');
const connText  = document.getElementById('connText');
const btnPingAll = document.getElementById('btnPingAll');
const lastPingEl = document.getElementById('lastPing');
const eventsEl = document.getElementById('events');

function setConnState(connected){
  connBadge.classList.toggle('ok', connected);
  connText.textContent = connected ? 'MQTT conectat' : 'MQTT deconectat';
}

/* DOORS map */
const DOORS = {
  1: { el: document.getElementById('d1'), cmd: 'locker/1/cmd' },
  2: { el: document.getElementById('d2'), cmd: 'locker/2/cmd' },
  3: { el: document.getElementById('d3'), cmd: 'locker/3/cmd' },
  4: { el: document.getElementById('d4'), cmd: 'locker/4/cmd' },
  5: { el: document.getElementById('d5'), cmd: 'locker/5/cmd' },
  6: { el: document.getElementById('d6'), cmd: 'locker/6/cmd' },
};

/* state + last seen (ms) */
const OFFLINE_MS = 20000; // 20s
document.getElementById('offlineMs').textContent = `${Math.floor(OFFLINE_MS/1000)}s`;

const state = {};
[1,2,3,4,5,6].forEach(i=>{
  state[i] = { lock:'LOCKED', door:'CLOSED', power:'ON', last:0 };
});

/* pending pings map (door -> {resolve, timer}) */
const pendingPings = {};

/* animate/render ușa */
function setOffline(id, yes){
  const d = DOORS[id]; if(!d) return;
  d.el.classList.toggle('offline', !!yes);
  if (yes) {
    const label = d.el.querySelector('.label');
    label.textContent = `Ușa ${id}\nOFFLINE`;
    d.el.classList.remove('open');
  }
}
function renderDoor(id){
  const s = state[id]; const d = DOORS[id]; if(!d) return;
  const el = d.el;
  const isOff = (Date.now() - s.last > OFFLINE_MS);
  setOffline(id, isOff);
  el.classList.toggle('nopower', s.power === 'OFF');
  el.classList.toggle('open', s.lock === 'UNLOCKED' && !isOff);
  if(!isOff){
    const label = el.querySelector('.label');
    label.textContent = `Ușa ${id}\n${s.lock} / ${s.door}${s.power==='OFF'?' / NOPWR':''}`;
  }
}

/* append event in list */
function appendEvent(text){
  const ev = document.createElement('div');
  ev.innerHTML = `<small style="color:#90c0e6">${new Date().toLocaleTimeString()}</small> — ${text}`;
  eventsEl.prepend(ev);
  while(eventsEl.childNodes.length>200) eventsEl.removeChild(eventsEl.lastChild);
}

/* =========================
   MQTT handlers
   ========================= */
client.on('connect', () => {
  setConnState(true);
  appendEvent('<b>MQTT</b> conectat');
  // subscribes: status per device + event topics
  [1,2,3,4,5,6].forEach(i=>{
    client.subscribe(`locker/${i}/status`, {qos:0});
    client.subscribe(`locker/${i}/event`, {qos:0});
    client.subscribe(`locker/${i}/event/new`, {qos:0});
  });
  lastPingEl.textContent = 'last ping: —';
});
client.on('reconnect', ()=> setConnState(false));
client.on('offline', ()=> setConnState(false));
client.on('error', (e)=> { setConnState(false); console.error('MQTT ERR', e); appendEvent('MQTT error'); });

/* global message handler */
client.on('message', (topic, payload) => {
  const txt = payload.toString();
  appendEvent(`<b>IN</b> ${topic} → ${txt}`);
  try {
    // status topics: locker/<id>/status
    const m = topic.split('/');
    if (m.length >=3 && m[0]==='locker' && m[2] === 'status') {
      const id = parseInt(m[1],10);
      try {
        const data = JSON.parse(txt);
        if (data.lock) state[id].lock = String(data.lock).toUpperCase();
        if (data.door) state[id].door = String(data.door).toUpperCase();
        if (data.power) state[id].power = String(data.power).toUpperCase();
      } catch(e){
        // if payload not JSON, just set last seen
      }
      state[id].last = Date.now();

      // if we have a pending ping for this id -> resolve it
      if (pendingPings[id]) {
        const p = pendingPings[id];
        clearTimeout(p.timer);
        p.resolve({ok:true, data: txt});
        delete pendingPings[id];
      }
      renderDoor(id);
      return;
    }

    // events (card reads)
    if (topic.endsWith('/event') || topic.endsWith('/event/new')) {
      // we already appended raw line; could parse JSON to show card id
      try {
        const o = JSON.parse(txt);
        if (o.type === 'CARD') {
          appendEvent(`<i>card</i> ${o.card24} — ${o.ok ? 'GRANTED' : 'DENIED'} ${o.first ? '('+o.first+' '+(o.last||'')+')':''}`);
        }
      } catch(e){}
      return;
    }

  } catch(e){
    console.error('message handler error', e);
  }
});

/* =========================
   Ping device logic
   ========================= */
function pingDevice(id, timeoutMs = 3500){
  return new Promise((resolve) => {
    if (!client || !client.connected) return resolve({ok:false});
    const statusTopic = `locker/${id}/status`;
    const reqTopic = `locker/${id}/status/get`;
    // if recent last seen, resolve fast with existing state
    if (Date.now() - state[id].last < 2000) {
      return resolve({ok:true, data: {lock: state[id].lock, door: state[id].door, power: state[id].power}});
    }
    // set pending
    if (pendingPings[id]) {
      // already pending -> treat as no
      return resolve({ok:false});
    }
    const timer = setTimeout(()=> {
      if (pendingPings[id]) {
        pendingPings[id].resolve({ok:false});
        delete pendingPings[id];
      }
    }, timeoutMs);
    pendingPings[id] = {
      resolve: (res) => { clearTimeout(timer); resolve(res); },
      timer
    };
    // publish request (ESP must listen and reply by publishing to status)
    client.publish(reqTopic, '');
    // also try to request retained status by republishing nothing to status (won't help)
  });
}

/* ping all sequential (for UI) */
async function pingAll() {
  lastPingEl.textContent = 'pinging…';
  const now = Date.now();
  for (let id=1; id<=6; id++){
    try {
      const res = await pingDevice(id, 3500);
      if (res.ok) {
        // update last and render (data may be raw JSON or we rely on state set by message handler)
        state[id].last = Date.now();
        renderDoor(id);
      } else {
        // mark offline
        setOffline(id, true);
      }
    } catch(e){
      console.error('ping err', e);
    }
  }
  lastPingEl.textContent = 'last ping: ' + (new Date()).toLocaleTimeString();
}

/* periodic watchdog: if last seen > OFFLINE_MS then ping once */
async function pingWatchdog(){
  // for each door that's probably offline, try a ping; this helps distinguish transient network from offline
  for (let id=1; id<=6; id++){
    const s = state[id];
    if (Date.now() - s.last > OFFLINE_MS) {
      const res = await pingDevice(id, 3000);
      if (res.ok) {
        state[id].last = Date.now();
        renderDoor(id);
      } else {
        setOffline(id, true);
      }
    }
  }
}

/* attach click handlers for doors */
Object.keys(DOORS).forEach(k=>{
  const id = parseInt(k,10);
  const {el, cmd} = DOORS[id];
  el.addEventListener('click', async ()=>{
    const s = state[id];
    const offline = (Date.now() - s.last > OFFLINE_MS);
    if (offline) { appendEvent(`Ușa ${id}: OFFLINE, ignor comanda.`); return; }
    if (s.power === 'OFF'){ appendEvent(`Ușa ${id}: fără alimentare, ignor comanda.`); return; }
    const next = (s.lock === 'LOCKED') ? 'UNLOCK' : 'LOCK';
    client.publish(cmd, next);
    appendEvent(`Trimis ${next} → ${cmd}`);
  });
});

/* UI button */
btnPingAll.addEventListener('click', () => {
  pingAll();
});

/* initial render + intervals */
[1,2,3,4,5,6].forEach(id=> renderDoor(id));
setInterval(()=>{ [1,2,3,4,5,6].forEach(id=> renderDoor(id)); }, 2000);
setInterval(pingWatchdog, 15000); // check every 15s
</script>
</body>
</html>
